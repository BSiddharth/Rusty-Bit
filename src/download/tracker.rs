use std::fmt;

use serde::{
    de::{self, Visitor},
    Deserialize, Deserializer, Serialize,
};

#[allow(dead_code)]
pub enum Event {
    //The first request to the tracker must include the event key with this value.
    STARTED,

    //Must be sent to the tracker if the client is shutting down gracefully.
    STOPPED,

    // Must be sent to the tracker when the download completes.
    // However, must not be sent if the download was already 100% complete when the client started.
    // Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
    COMPLETED,
}

pub struct TrackerRequest<'a> {
    // urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
    // Note that the value will be a bencoded dictionary, given the definition of the info key above.
    pub info_hash: [u8; 20],

    // urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
    // This is allowed to be any value, and may be binary data.
    // There are currently no guidelines for generating this peer ID.
    // However, one may rightly presume that it must at least be unique for your local machine,
    // thus should probably incorporate things like process ID and perhaps a timestamp recorded at startup.
    // See peer_id below for common client encodings of this field.
    pub peer_id: &'a str,

    // The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889.
    // Clients may choose to give up if it cannot establish a port within this range.
    pub port: u16,

    //  The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
    //  While not explicitly stated in the official specification, the concensus is that this should be the total number of bytes uploaded.
    pub uploaded: usize,

    // The total amount downloaded (since the client sent the 'started' event to the tracker) in
    // base ten ASCII. While not explicitly stated in the official specification, the consensus is
    // that this should be the total number of bytes downloaded.
    pub downloaded: usize,

    // The number of bytes this client still has to download in base ten ASCII.
    // Clarification: The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
    pub left: usize,

    //Setting this to 1 indicates that the client accepts a compact response.
    //The peers list is replaced by a peers string with 6 bytes per peer.
    //The first four bytes are the host (in network byte order), the last two bytes are the port (again in network byte order).
    //It should be noted that some trackers only support compact responses (for saving bandwidth) and either refuse requests without
    //"compact=1" or simply send a compact response unless the request contains "compact=0" (in which case they will refuse the request.)
    pub compact: u8,

    //Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
    // pub no_peer_id: usize,

    // If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified).
    // If not specified, then this request is one performed at regular intervals.
    pub event: Event,
}

// The tracker responds with "text/plain" document consisting of a bencoded dictionary
impl<'a> TrackerRequest<'a> {
    pub fn new(info_hash: [u8; 20], total_size: usize, peer_id: &'a str) -> Self {
        TrackerRequest {
            info_hash,
            peer_id,
            port: 6969,
            uploaded: 0,
            downloaded: 0,
            left: total_size,
            compact: 1,
            event: Event::STARTED,
        }
    }
    pub fn url(&self, base_url: &String) -> String {
        let url_encoded_info_hash = urlencoding::encode_binary(&self.info_hash);
        let mut url = String::new();
        url.push_str(base_url);
        url.push('?');
        url.push_str("info_hash=");
        url.push_str(&url_encoded_info_hash);
        url.push('&');
        url.push_str("peer_id=");
        url.push_str(self.peer_id);
        url.push('&');
        url.push_str("port=");
        url.push_str(&self.port.to_string());
        url.push('&');
        url.push_str("uploaded=");
        url.push_str(&self.uploaded.to_string());
        url.push('&');
        url.push_str("downloaded=");
        url.push_str(&self.downloaded.to_string());
        url.push('&');
        url.push_str("left=");
        url.push_str(&self.left.to_string());
        url.push('&');
        url.push_str("compact=");
        url.push_str(&(self.compact as u8).to_string());
        url
    }
}

#[derive(Debug)]
#[allow(dead_code)]
pub struct Peer {
    pub ip_addr: String,
    pub port: u16,
}
impl Peer {
    fn from_bytes(peer_bytes: &[u8; 6]) -> Peer {
        let mut ip_addr = String::new();
        for i in 0..4 {
            ip_addr
                .push_str(&u8::from_be_bytes(peer_bytes[i..i + 1].try_into().unwrap()).to_string());
            if i != 3 {
                ip_addr.push('.');
            }
        }
        let port = u16::from_be_bytes(peer_bytes[4..6].try_into().unwrap());
        Peer { ip_addr, port }
    }
}
// Setting compact to 1 indicates that the peers list is replaced by a peers string with 6 bytes per peer.
// The first four bytes are the host (in network byte order), the last two bytes are the port (again in network byte order)
// So in compact = 1 case peers cannot be a dictionary, it has to be a byte string
// For example, a client at the IP 10.10.10.5 listening on port 128
// would be coded as a string containing the following bytes 0A 0A 0A 05 00 80 (10 10 10 5 0 128)
#[allow(dead_code)]
#[derive(Debug)]
pub struct Peers(pub Vec<Peer>);

#[allow(dead_code)]
struct PeersVisitor;

impl<'de> Visitor<'de> for PeersVisitor {
    type Value = Peers;

    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        formatter.write_str("a Peer list string of size that is a multiple of 6")
    }

    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        if v.len() % 6 != 0 {
            return Err(E::custom(format!("length is {}", v.len())));
        }
        Result::Ok(Peers(
            v.chunks_exact(6)
                .map(|x| Peer::from_bytes(x.try_into().unwrap()))
                .collect(),
        ))
    }
}

impl<'de> Deserialize<'de> for Peers {
    fn deserialize<D>(deserializer: D) -> Result<Peers, D::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_bytes(PeersVisitor)
    }
}

#[allow(dead_code)]
#[derive(Deserialize, Debug)]
#[serde(untagged)]
pub enum TrackerResponseType {
    Success {
        // number of peers with the entire file, i.e. seeders (integer)
        complete: usize,

        // number of non-seeder peers, aka "leechers" (integer)
        incomplete: usize,

        // Interval in seconds that the client should wait between sending regular requests to the tracker
        interval: usize,

        peers: Peers,

        //A string that the client should send back on its next announcements.
        //If absent and a previous announce sent a tracker id, do not discard the old value; keep using it.
        #[serde(skip)]
        #[serde(rename = "tracker id")]
        tracker_id: String,
    },
    Failure {
        // The value is a human-readable error message as to why the request failed (string).
        #[serde(rename = "failure reason")]
        failure_reason: String,
    },
}

#[allow(dead_code)]
#[derive(Deserialize, Debug)]
pub struct TrackerResponse {
    #[serde(flatten)]
    pub tracker_response_type: TrackerResponseType,
}

#[allow(dead_code)]
#[derive(Serialize, Deserialize, Debug)]
pub struct HandShake {
    // string length of <pstr>, as a single raw byte
    // In version 1.0 of the BitTorrent protocol, pstrlen = 19
    pub pstrlen: u8,

    // string identifier of the protocol.
    // In version 1.0 of the BitTorrent protocol, pstr = "BitTorrent protocol" (len 19).
    pub pstr: [u8; 19],

    // eight (8) reserved bytes. All current implementations use all zeroes.
    // Each bit in these bytes can be used to change the behavior of the protocol.
    // An email from Bram suggests that trailing bits should be used first,
    // so that leading bits may be used to change the meaning of trailing bits.
    pub reserved: [u8; 8],

    // 20-byte SHA1 hash of the info key in the metainfo file.
    // This is the same info_hash that is transmitted in tracker requests.
    pub info_hash: [u8; 20],

    // 20-byte string used as a unique ID for the client.
    // This is usually the same peer_id that is transmitted in tracker requests
    // (but not always e.g. an anonymity option in Azureus).
    pub peer_id: [u8; 20],
}

impl HandShake {
    pub fn new(info_hash: [u8; 20], peer_id: [u8; 20]) -> HandShake {
        HandShake {
            pstrlen: 19,
            pstr: *b"BitTorrent protocol",
            reserved: [0; 8],
            info_hash,
            peer_id,
        }
    }
}

#[derive(Debug)]
pub enum PeerMsgType {
    // The keep-alive message is a message with zero bytes, specified with the length prefix set to zero.
    // There is no message ID and no payload.
    // Peers may close a connection if they receive no messages (keep-alive or any other message) for
    // a certain period of time, so a keep-alive message must be sent to maintain the connection alive
    // if no command have been sent for a given amount of time.
    // This amount of time is generally two minutes.
    // <len=0000>
    KeepAlive,

    // The choke message is fixed-length and has no payload.
    // <len=0001><id=0>
    Choke,

    // The unchoke message is fixed-length and has no payload.
    // <len=0001><id=1>
    Unchoke,

    // The interested message is fixed-length and has no payload.
    // <len=0001><id=2>
    Interested,

    // The not interested message is fixed-length and has no payload.
    // <len=0001><id=3>
    NotInterested,

    // The have message is fixed length.
    // The payload is the zero-based index of a piece that has just been successfully downloaded and verified via the hash.
    // <len=0005><id=4><piece index>
    Have,

    // The bitfield message may only be sent immediately after the handshaking sequence is completed,
    // and before any other messages are sent. It is optional, and need not be sent if a client has no pieces.
    // The bitfield message is variable length, where X is the length of the bitfield.
    // The payload is a bitfield representing the pieces that have been successfully downloaded.
    // The high bit in the first byte corresponds to piece index 0.
    // Bits that are cleared indicated a missing piece, and set bits indicate a valid and available piece.
    // Spare bits at the end are set to zero.

    // Some clients (Deluge for example) send bitfield with missing pieces even if it has all data.
    // Then it sends rest of pieces as have messages.
    // They are saying this helps against ISP filtering of BitTorrent protocol. It is called lazy bitfield.

    // A bitfield of the wrong length is considered an error.
    // Clients should drop the connection if they receive bitfields that are not of the correct size,
    // or if the bitfield has any of the spare bits set.

    // <len=0001+X><id=5><bitfield>
    Bitfield,

    // The request message is fixed length, and is used to request a block. The payload contains the following information:

    // index: integer specifying the zero-based piece index
    // begin: integer specifying the zero-based byte offset within the piece
    // length: integer specifying the requested length.
    // <len=0013><id=6><index><begin><length>
    Request,

    // The piece message is variable length, where X is the length of the block. The payload contains the following information:

    // index: integer specifying the zero-based piece index
    // begin: integer specifying the zero-based byte offset within the piece
    // block: block of data, which is a subset of the piece specified by index.
    // <len=0009+X><id=7><index><begin><block>
    Piece,

    // The cancel message is fixed length, and is used to cancel block requests.
    // The payload is identical to that of the "request" message.
    // It is typically used during "End Game".
    // <len=0013><id=8><index><begin><length>
    Cancel,
}

impl TryFrom<u8> for PeerMsgType {
    type Error = &'static str;
    fn try_from(value: u8) -> Result<Self, &'static str> {
        match value {
            0 => Ok(PeerMsgType::KeepAlive),
            1 => Ok(PeerMsgType::Choke),
            2 => Ok(PeerMsgType::Unchoke),
            3 => Ok(PeerMsgType::Interested),
            4 => Ok(PeerMsgType::NotInterested),
            5 => Ok(PeerMsgType::Have),
            6 => Ok(PeerMsgType::Bitfield),
            7 => Ok(PeerMsgType::Request),
            8 => Ok(PeerMsgType::Piece),
            9 => Ok(PeerMsgType::Cancel),
            _ => Err("Conversion of u8 to PeerMsgType not possible"),
        }
    }
}
