use std::{fmt, net::IpAddr, str::FromStr, string};

use rand::distributions::{Alphanumeric, DistString};
use serde::{
    de::{self, Visitor},
    Deserialize, Deserializer,
};

#[allow(dead_code)]
pub enum Event {
    //The first request to the tracker must include the event key with this value.
    STARTED,

    //Must be sent to the tracker if the client is shutting down gracefully.
    STOPPED,

    // Must be sent to the tracker when the download completes.
    // However, must not be sent if the download was already 100% complete when the client started.
    // Presumably, this is to allow the tracker to increment the "completed downloads" metric based solely on this event.
    COMPLETED,
}

pub struct TrackerRequest {
    // urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
    // Note that the value will be a bencoded dictionary, given the definition of the info key above.
    pub info_hash: [u8; 20],

    // urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
    // This is allowed to be any value, and may be binary data.
    // There are currently no guidelines for generating this peer ID.
    // However, one may rightly presume that it must at least be unique for your local machine,
    // thus should probably incorporate things like process ID and perhaps a timestamp recorded at startup.
    // See peer_id below for common client encodings of this field.
    pub peer_id: String,

    // The port number that the client is listening on. Ports reserved for BitTorrent are typically 6881-6889.
    // Clients may choose to give up if it cannot establish a port within this range.
    pub port: u16,

    //  The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
    //  While not explicitly stated in the official specification, the concensus is that this should be the total number of bytes uploaded.
    pub uploaded: usize,

    // The total amount downloaded (since the client sent the 'started' event to the tracker) in
    // base ten ASCII. While not explicitly stated in the official specification, the consensus is
    // that this should be the total number of bytes downloaded.
    pub downloaded: usize,

    // The number of bytes this client still has to download in base ten ASCII.
    // Clarification: The number of bytes needed to download to be 100% complete and get all the included files in the torrent.
    pub left: usize,

    //Setting this to 1 indicates that the client accepts a compact response.
    //The peers list is replaced by a peers string with 6 bytes per peer.
    //The first four bytes are the host (in network byte order), the last two bytes are the port (again in network byte order).
    //It should be noted that some trackers only support compact responses (for saving bandwidth) and either refuse requests without
    //"compact=1" or simply send a compact response unless the request contains "compact=0" (in which case they will refuse the request.)
    pub compact: u8,

    //Indicates that the tracker can omit peer id field in peers dictionary. This option is ignored if compact is enabled.
    // pub no_peer_id: usize,

    // If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified).
    // If not specified, then this request is one performed at regular intervals.
    pub event: Event,
}

// The tracker responds with "text/plain" document consisting of a bencoded dictionary
impl TrackerRequest {
    pub fn new(info_hash: [u8; 20], total_size: usize) -> Self {
        let peer_id = Alphanumeric.sample_string(&mut rand::thread_rng(), 20);

        TrackerRequest {
            info_hash,
            peer_id,
            port: 6969,
            uploaded: 0,
            downloaded: 0,
            left: total_size,
            compact: 1,
            event: Event::STARTED,
        }
    }
    pub fn url(&self, base_url: &String) -> String {
        let url_encoded_info_hash = urlencoding::encode_binary(&self.info_hash);
        let mut url = String::new();
        url.push_str(base_url);
        url.push('?');
        url.push_str("info_hash=");
        url.push_str(&url_encoded_info_hash);
        url.push('&');
        url.push_str("peer_id=");
        url.push_str(&self.peer_id);
        url.push('&');
        url.push_str("port=");
        url.push_str(&self.port.to_string());
        url.push('&');
        url.push_str("uploaded=");
        url.push_str(&self.uploaded.to_string());
        url.push('&');
        url.push_str("downloaded=");
        url.push_str(&self.downloaded.to_string());
        url.push('&');
        url.push_str("left=");
        url.push_str(&self.left.to_string());
        url.push('&');
        url.push_str("compact=");
        url.push_str(&(self.compact as u8).to_string());
        url
    }
}

#[derive(Debug)]
struct Peer {
    ip_addr: String,
    port: u16,
}
impl Peer {
    fn from_bytes(peer_bytes: &[u8; 6]) -> Peer {
        let mut ip_addr = String::new();
        for i in 0..4 {
            ip_addr
                .push_str(&u8::from_be_bytes(peer_bytes[i..i + 1].try_into().unwrap()).to_string());
            if i != 3 {
                ip_addr.push('.');
            }
        }
        let port = u16::from_be_bytes(peer_bytes[4..6].try_into().unwrap());
        Peer { ip_addr, port }
    }
}
// Setting compact to 1 indicates that the peers list is replaced by a peers string with 6 bytes per peer.
// The first four bytes are the host (in network byte order), the last two bytes are the port (again in network byte order)
// So in compact = 1 case peers cannot be a dictionary, it has to be a byte string
// For example, a client at the IP 10.10.10.5 listening on port 128
// would be coded as a string containing the following bytes 0A 0A 0A 05 00 80 (10 10 10 5 0 128)
#[allow(dead_code)]
#[derive(Debug)]
struct Peers(Vec<Peer>);

#[allow(dead_code)]
struct PeersVisitor;

impl<'de> Visitor<'de> for PeersVisitor {
    type Value = Peers;

    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        formatter.write_str("a Peer list string of size that is a multiple of 6")
    }

    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        if v.len() % 6 != 0 {
            return Err(E::custom(format!("length is {}", v.len())));
        }
        Result::Ok(Peers(
            v.chunks_exact(6)
                .map(|x| Peer::from_bytes(x.try_into().unwrap()))
                .collect(),
        ))
    }
}

impl<'de> Deserialize<'de> for Peers {
    fn deserialize<D>(deserializer: D) -> Result<Peers, D::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_bytes(PeersVisitor)
    }
}

#[allow(dead_code)]
#[derive(Deserialize, Debug)]
#[serde(untagged)]
enum TrackerResponseType {
    Success {
        // number of peers with the entire file, i.e. seeders (integer)
        complete: usize,

        // number of non-seeder peers, aka "leechers" (integer)
        incomplete: usize,

        // Interval in seconds that the client should wait between sending regular requests to the tracker
        interval: usize,

        peers: Peers,

        //A string that the client should send back on its next announcements.
        //If absent and a previous announce sent a tracker id, do not discard the old value; keep using it.
        #[serde(skip)]
        #[serde(rename = "tracker id")]
        tracker_id: String,
    },
    Failure {
        // The value is a human-readable error message as to why the request failed (string).
        #[serde(rename = "failure reason")]
        failure_reason: String,
    },
}

#[allow(dead_code)]
#[derive(Deserialize, Debug)]
pub struct TrackerResponse {
    #[serde(flatten)]
    tracker_response_type: TrackerResponseType,
}
